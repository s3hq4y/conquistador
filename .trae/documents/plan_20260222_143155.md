## 通用状态驱动属性算法实现计划（配置驱动）

### 1. 核心原则
- **类型定义放在 JSON 配置文件中**（traits.json）
- **程序只提供通用接口和算法**，不硬编码具体状态类型

### 2. 程序接口 (types.ts)

**通用状态效果接口**（程序提供）：
```typescript
export type EffectType = 'linear' | 'threshold' | 'percentage';

export interface StateEffect {
  state: string;              // 状态类型名称（从JSON读取，不枚举）
  stat: string;                // 属性名称（从JSON读取）
  type: EffectType;            // 算法类型
  value?: number;              // 算法参数
  minPercent?: number;         // 最小百分比
  maxPercent?: number;         // 最大百分比
}
```

### 3. Trait 接口保持简洁 (types.ts)
```typescript
export interface Trait {
  id: string;
  name: string;
  type: string;
  description?: string;
  requires?: string[];
  children?: string[];
  stats?: Record<string, number>;  // 通用Map，属性名作为key
  tags?: string[];
  combatBonuses?: CombatBonus[];
  stateEffects?: StateEffect[];     // 状态效果（从JSON配置读取）
}
```

### 4. 算法实现 (TraitManager.ts 或新建 StateCalculator.ts)

程序提供通用算法，不关心具体状态类型：
```typescript
export class StateCalculator {
  calculate(
    baseValue: number,
    effect: StateEffect,
    currentPercent: number
  ): number {
    switch (effect.type) {
      case 'linear':
        return baseValue * (currentPercent / 100);
      case 'threshold':
        if (currentPercent < (effect.value || 50)) {
          const minPct = effect.minPercent || 50;
          return baseValue * Math.max(minPct / 100, currentPercent / 100);
        }
        return baseValue;
      case 'percentage':
        const penalty = (effect.value || 100) / 100;
        return baseValue * (1 - (1 - currentPercent / 100) * penalty);
      default:
        return baseValue;
    }
  }
}
```

### 5. calculateStats 修改 (TraitManager.ts)

```typescript
calculateStats(
  traitIds: string[], 
  stateValues?: Map<string, number>  // Map<状态类型, 当前百分比>
): Record<string, number> {
  // 1. 收集所有基础属性
  const allTraits = this.getUnitAllTraits(traitIds);
  let baseStats: Record<string, number> = {};
  
  for (const trait of allTraits) {
    if (trait.stats) {
      baseStats = this.mergeStats(baseStats, trait.stats);
    }
  }

  // 2. 应用状态影响（如有传入状态值）
  if (stateValues) {
    const effects = allTraits.flatMap(t => t.stateEffects || []);
    for (const statKey of Object.keys(baseStats)) {
      const statEffects = effects.filter(e => e.stat === statKey);
      for (const effect of statEffects) {
        const currentPercent = stateValues.get(effect.state) ?? 100;
        baseStats[statKey] = this.stateCalculator.calculate(
          baseStats[statKey], 
          effect, 
          currentPercent
        );
      }
    }
  }

  return baseStats;
}
```

### 6. JSON 配置示例 (traits.json)

**步兵（HP驱动属性）**：
```json
{
  "infantry": {
    "id": "infantry",
    "stats": { "hp": 100, "attack": 10, "defense": 15, "movement": 4, "range": 1 },
    "stateEffects": [
      { "state": "hp", "stat": "attack", "type": "linear" },
      { "state": "hp", "stat": "defense", "type": "linear" },
      { "state": "hp", "stat": "movement", "type": "threshold", "value": 50, "minPercent": 50 }
    ]
  }
}
```

**精灵单位（MP驱动魔法）**：
```json
{
  "mage": {
    "id": "mage",
    "stats": { "hp": 60, "mp": 50, "attack": 5, "magic": 20, "movement": 4 },
    "stateEffects": [
      { "state": "mp", "stat": "magic", "type": "linear" }
    ]
  }
}
```

### 7. 扩展性

- 新增状态类型：只需在 traits.json 中配置，无需改代码
- 新增算法：只需在 StateCalculator 中添加新的 case
- 程序完全解耦，只提供通用框架